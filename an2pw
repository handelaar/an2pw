#!/usr/bin/env php
<?php

/**
 * an2pw - Convert Akoma Ntoso XML to PublicWhip XML
 * 
 * WARNING: HIGHLY-EXPERIMENTAL ALPHA-AS-FUCK TEST CODE
 * WARNING: NOT FOR USE
 * 
 * @version  0.1.0
 * @license  https://opensource.org/licenses/GPL-2.0 GPL 2
 * @author   John Handelaar <john@handelaar.org>
 */ 


 // Test script; to be removed before release
$akomantoso = new ConvertAkomantosoToPublicwhip('data/dail20181127.xml');
$akomantoso->setChamber('dail');
$akomantoso->setSpeakers(array('eID' => 'publicwhip_id'));
$akomantoso->toPublicWhip();
$akomantoso->write();
die();

class ConvertAkomantosoToPublicwhip {

    public function __construct($filename) {
        
        # TODO: Make this actually do something later
        $this->debug = FALSE;
        
        # Load example file 
        # TODO: replace this with specified config options
        $this->akoma = simplexml_load_file($filename);


        # Filename assumed to contain date in format YYYYmmdd; this regex just removes non-numeric chars from filename
        # TODO: move this to config 
        $this->date = DateTime::createFromFormat('Ymd H:i:s', preg_replace("/[^0-9]/", "", $filename) . " 00:00:00");
        

        # TODO: move these to config
        $this->namespace = 'com.kildarestreet'; # use eg 'uk.org.publicwhip' if you're not in Ireland
        $this->revision = 'a';


        # Start item counter
        $this->counter = 0;


        # Used later to tag answers to questions
        $this->lastwasquestion = FALSE;


        # Create bucket for PublicWhip XML output
        $this->output = array();


        # SimpleXML's xpath support doesn't work with Akoma Ntoso files 
        # unless the namespace is registered and then used in xpath calls
        # 
        # TODO: wrap this around a test for network connectivity because
        # everything will probably die on its arse if the referenced doc is
        # not available to this class

        $this->akoma->registerXPathNamespace('ns', "http://docs.oasis-open.org/legaldocml/ns/akn/3.0/CSD13");

    }


    public function toPublicWhip() {
        
        // Loop through each debateSection in Akoma Ntoso simplexml object

        foreach($this->akoma->xpath('//ns:debate/ns:debateBody/ns:debateSection') as $section) {

            // Generate publicwhip <majorheading>

            $this->counter ++;
            if (isset($section->heading)) {
                $row = $this->heading("major",$section->heading);
                $this->output[] .= $row;
            }

            // Loop through child objects and process by type; 
            
            foreach($section->children() as $child) {

                switch($child->getName()) {

                    case "heading":

                        // ignore heading because we just did that above
                        break;
                    
                    case "summary":

                        $this->counter++;
                        $this->output[] .= $this->speechProcedural($child);
                        break;                    
                    
                    case "speech":

                        $this->counter++;
                        $this->output[] .= $this->speech($child);
                        break;                    

                    // If there is a nested debateSection, do that loop inside this loop
                    
                    case "debateSection":

            			$this->counter++;
                        $row = $this->heading("minor",$child->heading);
                        $this->output[] .=  $row;
                        foreach($child->children() as $grandchild) {

                            switch($grandchild->getName()) {
                                case "heading":
                                    break;

                                case "summary":
                                    $this->counter++;
                                    $this->output[] .= $this->speechProcedural($grandchild);
                                    break;                    
            
                                case "speech":
                                    $this->counter++;
                                    $this->output[] .= $this->speech($grandchild);
                                    break;

                                /*case "question":
                                    $this->counter++;
                                    $this->output[] .= $this->question($grandchild);
                                    break;*/

                                default:
                                    $this->counter++;
                                    echo "    " . $this->counter . "  FATAL: unable to identify grandchild of type '" . $grandchild->getName() . "'";
                                    $domnode = dom_import_simplexml($grandchild);
                                    echo " --  line " . $domnode->getLineNo() . "\n";
                                    unset($domnode);
                                    #die();
                                    break;
                                }
                            }
                        
                        break;


                    // Unrecognised child types cause a crash so that we can't ignore
                    // that this processor is incomplete

                    default:
                        $this->counter++;
                        echo "    " . $this->counter . "  FATAL: unable to identify child of type '" . $child->getName() . "'";
                        $domnode = dom_import_simplexml($child);
                        echo " --  line " . $domnode->getLineNo() . "\n";
                        unset($domnode);
                        die();
                        break;
                }

            }

        }
            
    }

    private function speechProcedural($object) {

        $domnode = dom_import_simplexml($object);

        $speech =  "    <speech " .
            'id="' . $this->namespace . '/' . $this->chamber . '/' . $this->date->format('Y-m-d') . $this->revision . '.' . 
            $this->counter . '" ' . 'nospeaker="true" ';

        # Don't add timestamp if we haven't yet encountered an object with a timestamp
        if($this->date->format('H:i:s') !== "00:00:00") {
            $speech .= 'time="' . $this->date->format('H:i:s') . '" '; 
        }

        $speech .= 'url="' . '"><p>' . trim($domnode->nodeValue) . "</p></speech>";
        
        return $speech;

    }


    private function speech($object) {

        $this->answersuffix = "";

        if($this->lastwasquestion) {
            $this->answersuffix = ".r";
            $this->lastwasquestion = FALSE;
        }

        $speech = "    <speech " .
            'id="' . $this->namespace . '/' . $this->chamber . '/' . $this->date->format('Y-m-d') . $this->revision . '.' . 
            $this->counter . $this->answersuffix . '" ' . 'speakerid="' . str_replace('#','',trim($object->attributes()->by)) . '" ' .
            'speakername="' .  trim($object->from)  .  '" ' ;  

        # Don't add timestamp if we haven't yet encountered an object with a timestamp
        if($this->date->format('H:i:s') !== "00:00:00") {
            $speech .= 'time="' . $this->date->format('H:i:s') . '" '; 
        }

        $speech .= 'url="' . '">';
        
        foreach($object as $content) {
            if(isset($content->attributes()->eId)) {
                $speech .= $content->asXML();
            }
        }
        $speech .= "</speech>";

        return $speech;

    }


    private function heading($type,$object) {
        
        // Get time for publicwhip format
        // "2018-12-12T10:30:00+00:00" -> "10:30:00"
        
        $objAttrs = $object->recordedTime->attributes();
        $this->date = DateTime::createFromFormat('Y-m-d\TH:i:sP', (string) $objAttrs["time"], new DateTimeZone('Europe/Dublin'));
        $date = date_format($this->date,'Y-m-d');
        $time = date_format($this->date,'H:i:s');
        
        $output = "<$type-heading " .
            'id="' . $this->namespace . '/' . $this->chamber . '/' . $date . $this->revision . '.' . $this->counter . '" ' .
            'nospeaker="true" ' .
            'time="' . $time . '" ' .
            'url="' . '">' .
            trim($object) .
            "</$type-heading>";
        
        return($output);
    
    }


    public function setChamber(string $chamber) {
        
        $this->chamber=$chamber;
        return;
    }


    public function setSpeakers(array $speakers) {
        
        # do things
        
        return;
    }

    public function write() {

    	echo implode("\n",$this->output);
    	echo "\n";

        # do things

        return;
    }

}
